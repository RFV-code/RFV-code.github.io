{
    "docs": [
        {
            "location": "/about/", 
            "text": "About Me\n\n\nI'm a financial person and a computer person. I love to think outside of the box and to understand the bigger picture.\nI have a keen interest in how computers and how computation work in general and I enjoy understanding topics such as the \nP vs NP\n, \nhalting problem\n, understanding different programming paradigms, knowing how our \nturing complete\n machines work and more specifically the \nVon Neuman architecture\n. Then, I strongly believe that although it is not necessary to be an expert in very low level programming, it is \nimperative (pun)\n that one at least know the basics of \nassembler programming\n. Lastly, how can any programmer understand the system they are working with and understand why it works the way it does without understanding how the modern day computer and mobile phone evolved into the complex machines that we have today. One really has to do some background research into the history of computers going back to the \ndifference machine\n and then forwarding through the world wars, understanding the need at the time for computers, how they where designed, the physical realities of the designs and implementation of those actual machines, and how concepts and jargon, which we still use today evolved. How can you understand these concepts without understanding where they came from and what they actually mean? \n\n\nMay takeaway is that due to economies of scale the entire Information Technology Industry has to move forward in a way that is backwards compatible. It's not that we can't use the newest physical developments to completely redesign how our computers work, its just that there won't be enough people initially to support such an en-devour and hence not enough money. Due to economies of scale we can leave CPU design to Intel, AMD and ARM and then with the help of the \nimpossibly\n amazing technology of \nphotolithography\n, they can spend Billions on development and then mass produce CPU's at low cost. The same goes for \njavascript\n (for instance), a programming language that is not well designed but loved by millions because that is what they came to know. Why is Javascript so pervasive? Because all the existing websites that use it already would have to be re-written if it was replaced, and secondly and wisely, web-browser developers realized that in order to avoid \nfragmentation\n, it would be best to just stick with the devil they know. Imagine if every browser had its own language, the web would die very quickly.\n\n\nLastly: I also enjoy knowing how the following works: \nboolean algebra\n, \nsequential logic\n, \ntransistors\n, \nlogic gates\n, \nbinary numbers\n.\n\n\nThese are just some of the things which keeps my head from cooling down \n(permanently)\n, the other is computation theory and computation complexity theory, another detour on my road to computing guru-ship.\n\n\nCurrently I am enjoying the low cost of living in Philippines as I am advancing my programming skills: focusing on the following 1st:\n\n\n\n\nfunctional programming|clojure\n\n\npython| (cython, ctypes)(scrapy, django)numpy, timeit\n\n\njava\n\n\nweb programming| javascrips, clojurescript, MEAN stack\n\n\n\n\nFor info on where to contact me: \nRFVenter\n\n\nLearning Steps\n\n\nCertification\n\n\nTreehouse\n\n\nUdemy\n\n\nEdX\n\n\nCousera\n\n\nFreecodecamp\n\n\nCodingdojo\n\n\nCodeschool\n\n\nUdacity\n\n\nCodecademy\n\n\nEduonix\n  \n\n\nPython\n\n\n(cython, ctypes)(scrapy, django)numpy, timeit\n\n\nJava\n\n\njython, android\n\n\nFunctional programming\n\n\nClojure\n\n\nUdemy Learning Clojure\n\n\nUdemy Learning Clojure Fundamentals for Beginners\n\n\nClojure Test\n  \n\n\nRacket\n\n\nthe modern implementation of scheme  \n\n\nHaskell\n\n\nEdX Functional programming with Professor Meijer\n\n\nC9 Lectures with Erik Meijer\n\n\nFrege\n  \n\n\nWeb Programming\n\n\nMEAN(MongoDB, ExpressJS, AngularJS, NodeJS)\n\n\nOther\n\n\n    git\n    ai, datamining|\n        deep learning vs most efficient\n        statespace prunning\n        python platform\n            numpy, scikit-learn\n            data visualization\n            data mining\n        mathematics, rapidminer, r\n    gui|pyqt, kivy, wxpython, camelot\n    c|\n        go the qt route\n        c standard library (gnu c library)\n        linux system proramming in c\n        compiler|gcc, clang\n        build system|cmake\n        libraries|qt\n    debuging|\n        (gdb, pdb, winpdb) unit testing (rope) logging, assert, apport\n        pdb, bugjar, ddd\n        breakpoints, conditional breakpoints, tempory breakpoints\n        watchpoint\n            instructs the debugger to pause execution of the pro-\n            gram whenever the value of a specified variable changes.\n        logging, not print\n        asserts\n        unit tests\n    refactoring|improve design but not behaviour always with unit tests as safetynet, never refactor while \n        changing behaviour and vice versa\n    prolog\n    lua\n\n\n\n\nComputer jargon\n\n\nObserver pattern\n\n\nIs widely used in doing event-driven programming with GUI frameworks. Don't call us. Give us your telephone number, and we will call you if and when we have a job for you.\n\n\nPolymorphism\n\n\nThe provision of a single interface to entities of different types. A polymorphic type is one whose operations can also be applied to values of some other type, or types.\n\n\nGUI (Graphical User Interface)\n\n\nA type of user interface that allows users to interact with electronic devices through graphical icons and visual indicators such as secondary notation, instead of text-based user interfaces, typed command labels or text navigation. GUIs were introduced in reaction to the perceived steep learning curve of command-line interfaces (CLIs), which require commands to be typed on a computer keyboard.\n\n\nOOP (Object Oriented Programming)\n\n\nA programming paradigm based on the concept of \"objects\", which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of \"this\" or \"self\"). In OOP, computer programs are designed by making them out of objects that interact with one another. There is significant diversity of OOP languages, but the most popular ones are class-based, meaning that objects are instances of classes, which typically also determine their type.\nMany of the most widely used programming languages are multi-paradigm programming languages that support object-oriented programming to a greater or lesser degree, typically in combination with imperative, procedural programming. Significant object-oriented languages include Java, C++, C#, Python, PHP, Ruby, Perl, Delphi, Objective-C, Swift, Common Lisp, and Smalltalk.\n\n\nAbstraction\n\n\nThe process of picking out (abstracting) common features of objects and procedures. A programmer would \nuse abstraction, for example, to note that two functions perform almost the same task and can be combined \ninto a single function. Abstraction is one of the most important techniques in software engineering and is\nclosely related to two other important techniques - encapsulation and information hiding. All three\ntechniques are used to reduce complexity.\n\n\nAlgorithm\n\n\nA formula or set of steps for solving a particular problem. To be an algorithm, a set of rules must be unambiguous and have a clear stopping point. Algorithms can be expressed in any language, from natural languages like English or French to programming languages.\nWe use algorithms every day. For example, a recipe for baking a cake is an algorithm. Most programs, with the exception of some artificial intelligence applications, consist of algorithms.\n\n\nBug\n\n\nAn error or defect in software or hardware that causes a program to malfunction. According to folklore, the first computer bug was an actual bug. Discovered by Lieutenant Grace Hopper in 1945 at Harvard, a moth trapped between two electrical relays of the Mark II Aiken Relay Calculator caused the whole machine to shut down.\n\n\nConstant\n\n\nIn programming, a constant is a value that never changes.\n\n\nDynamic Variable\n\n\nIn programming, a dynamic variable is a variable whose address is determined when the program is run. In contrast, a static variable has memory reserved for it at compilation time.\n\n\nEncapsulation\n\n\nIn programming, the process of combining elements to create a new entity. For example, a procedure is a type of encapsulation because it combines a series of computer instructions. Likewise, a complex data type, such as a record or class, relies on encapsulation. Object-oriented programming languages rely heavily on encapsulation to create high-level objects. Encapsulation is closely related to abstraction and information hiding.\n\n\nException\n\n\nA condition, often an error, that causes the program or microprocessor to branch to a different routine. The terms interrupt and exception are very close in meaning. Both can be used to refer to either hardware or software. The only real difference is that an exception usually indicates an error condition.\n\n\nFlow Control\n\n\nIn communications\n\n\nThe process of adjusting the flow of data from one device to another to ensure that the receiving device can handle all of the incoming data. This is particularly important where the sending device is capable of sending data much faster than the receiving device can receive it.\n\n\nIn programming\n\n\nThe statements and other constructs that control the order in which operations are executed. For example, common looping statements such as for\u2026next and while are known as flow control statements. Branching statements, such as if\u2026then are also part of a programming language's flow control mechanism.\n\n\nGarbage In, Garbage Out\n\n\nif invalid data is entered into a system, the resulting output will also be invalid. Although originally applied to computer software, the axiom holds true for all systems, including, for example, decision-making systems.\n\n\nHeuristic Programming\n\n\nA branch of artificial intelligence, which uses heuristics - common-sense rules drawn from experience - to solve problems. This is in contrast to algorithmic programming, which is based on mathematically provable procedures. Heuristic programming is characterized by programs that are self-learning; they get better with experience. Heuristic programs do not always reach the very best result but usually produce a good result. Many expert systems use heuristic programming.\n\n\nInformation Hiding\n\n\nThe process of hiding details of an object or function. Information hiding is a powerful programming technique because it reduces complexity. One of the chief mechanisms for hiding information is encapsulation - combining elements to create a larger entity. The programmer can then focus on the new object without worrying about the hidden details. In a sense, the entire hierarchy of programming languages - from machine languages to high-level languages - can be seen as a form of information hiding.\nalso used to prevent programmers from changing - intentionally or unintentionally - parts of a program.\n\n\nIteration\n\n\nA single pass through a group of instructions. Most programs contain loops of instructions that are executed over and over again. The computer iterates through the loop, which means that it repeatedly executes the loop.\n\n\nLoop\n\n\nIn programming, a loop is a series of instructions that is repeated until a certain condition is met. Each pass through the loop is called an iteration. Loops constitute one of the most basic and powerful programming concepts.\n\n\nMemory Leak\n\n\nA bug in a program that prevents it from freeing up memory that it no longer needs. As a result, the program grabs more and more memory until it finally crashes because there is no more memory left.\n\n\nMutex\n\n\nShort for mutual exclusion object. In computer programming, a mutex is a program object that allows multiple program threads to share the same resource, such as file access, but not simultaneously. When a program is started, a mutex is created with a unique name. After this stage, any thread that needs the resource must lock the mutex from other threads while it is using the resource. The mutex is set to unlock when the data is no longer needed or the routine is finished.\n\n\nParse\n\n\nIn linguistics, to divide language into small components that can be analyzed. \nParsing is often divided into lexical analysis and semantic parsing. Lexical analysis concentrates on dividing strings into components, called tokens, based on punctuation and other keys. Semantic parsing then attempts to determine the meaning of the string.\n\n\nRefactoring\n\n\nImproving the design of existing software code. Refactoring doesn't change the observable behavior of the software; it improves its internal structure. For example, if a programmer wants to add new functionality to a program, he may decide to refactor the program first to simplify the addition of new functionality in order to prevent software entropy.\n\n\nRegression Testing\n\n\nThe selective retesting of a software system that has been modified to ensure that any bugs have been fixed and that no other previously-working functions have failed as a result of the reparations and that newly added features have not created problems with previous versions of the software. Also referred to as verification testing, regression testing is initiated after a programmer has attempted to fix a recognized problem or has added source code to a program that may have inadvertently introduced errors. It is a quality control measure to ensure that the newly-modified code still complies with its specified requirements and that unmodified code has not been affected by the maintenance activity.\n\n\nRuntime\n\n\nOccurring while a program is executing. For example, a runtime error is an error that occurs during program execution and a runtime library is a library of routines that are bound to the program during execution. In contrast, compile-time refers to events that occur while a program is being compiled.\n\n\nScalable\n\n\nhow well a hardware or software system can adapt to increased demands. For example, a scalable network system would be one that can start with just a few nodes but can easily expand to thousands of nodes. Scalability can be a very important feature because it means that you can invest in a system with confidence you won't outgrow it.\n\n\nSemaphore\n\n\nA hardware or software flag. In multitasking systems, a semaphore is a variable with a value that indicates the status of a common resource. Its used to lock the resource that is being used. A process needing the resource checks the semaphore to determine the resource's status and then decides how to proceed.\n\n\nSoftware Entropy\n\n\nThe tendency for software, over time, to become difficult and costly to maintain. A software system that undergoes continuous change, such as having new functionality added to its original design, will eventually become more complex and can become disorganized as it grows, losing its original design structure.\n\n\nStateless\n\n\nHaving no information about what occurred previously. Most modern applications maintain state, which means that they remember what you were doing last time you ran the application, and they remember all your configuration settings. This is extremely useful because it means you can mold the application to your working habits.\n\n\nVirtual Machine\n\n\nA self-contained operating environment that behaves as if it is a separate computer. For example, Java applets run in a Java virtual machine (VM) that has no access to the host operating system.\n\n\nWhite Box Testing\n\n\nAlso known as glass box, structural, clear box and open box testing. A software testing technique whereby explicit knowledge of the internal workings of the item being tested are used to select the test data. Unlike black box testing, white box testing uses specific knowledge of programming code to examine outputs. The test is accurate only if the tester knows what the program is supposed to do. He or she can then see if the program diverges from its intended goal. White box testing does not account for errors caused by omission, and all visible code must also be readable.\n\n\nMy Thoughts\n\n\n    python|\n        syntax,  c interop,  vm\n    programming is about using other peoples code. understanding what they mean, so understanding the language that they use to describe what is happening. there is much confusion, misunderstanding and ambiguity.\n    remove goto|reduced complexity\n    add concurrency|add complexity\n    add multiple inheritance|add complexity\n    event driven programming|\n        still procedural but set of instructions that happen on some event happening\n    easy of programming|\n        the code/test cycle, easy for new users but can go all the way to most low level\n    pointers|\n        pointing to data, pointing to function, pointing to loop, pointing to branching\n    lowest common denominator of turing|\n        jump, branch, change\n        i/o (memory, interupts)\n        memory access\n    asm|\n        registers\n        functions|\n            Function call problems\n                Calling and returning\n                Passing parameters\n                Storing local variables\n                Handling registers without interference\n                Returning values\n        heap, stack\n    c|\n        no extensive use of goto (mostly removed)\n        pointers\n    c++|\n        Another distinction is the use of the terms public and private within the class definition.\n    python|\n        The primary advantage of an interpreted language is greater platform-independence. The same source code can be distributed for use on different computing platforms, so long as each platform has a valid interpreter.\n\n\n\n\nMy Programming Language\n\n\nAbstractions are good, reality is better. Due to the realities of computation complexity, the higher level a language the slower it will be. If the programmer has no idea of the underlying of what the language is doing then the programmer looses grip on the program and the fact that it actually executes in TIME and a real MACHINE. Programs will always require real world resources. \n\n\nProgram in high level and selectively cut out features in order to speed up the execution all the way down.\n\n\nWhy are programming languages syntax so unintuitive and ugly, verbose? Make a clean, simple syntax.\n\n\n    test, jump, change\n    length, speed\n    start to finish, programming is a set of instructions followed from start to finish, with conditional jumps around.\n    runtime, compile time\n    native, vm\n    source protect\n    interop, c, python\n    dynamic, typed\n    functional, oop, event driven\n    if, when, event\n    goto, tabed, debug, exception, assert (commenting), introspection\n    namespace|\n        namespace is just a way to organise code\n        also object inheritance is just code organise method\n    why text,language?|\n        because the code is linear, variable names serve as a type of documentation and visual que, more information in source code means more space to add extra info for programmer to be able to understand the code\n        documentation for everything, because its called language so use language to describe what happens in computer world\n        even pics, html\n    must be tab seperated (like python) with optional static typing all the way down to c abstract syntax tree compatible without interpreter.\n    must be compatible with existing c/c++ objects and also existing python object files.\n    basically python/cython but may differ slightly to include new features, like static typing\n    remove the gil and replace vm with llvm type vm;\n    use llvmir for permision control of code\n    different levels of execution|\n        native, vm, both|\n        each level has feature on/off|\n            exceptions (exception tree, swith off lower down)\n            garbage collection, memory allocation (malloc), pointers\n            dynamic/static typing\n            encapsulation\n        dynamic recompilation\n        repl\n        introspective capabilities\n        compile-time, the less work there is to be done at run-time.\n        run time|\n            compilation\n            garbage collection\n            exceptions\n            dynamic typing\n                duck typing\n                    call by name, dictionaries\n    llvm|some are more critical of this sandboxing technology as it has substantial or substantive interoperability issues.\n        asm, llvmir, c, c++ (libraries compatible), new language\n            java (libraries not compatible)\n            python (libraries not compatible)        \n    c/c++ to my langauge converter\n    language compatibility with c, c++, java?\n    concurrency\n         These sorts of problems with shared resources require the use of concurrency control, or non-blocking algorithms.\n         Go Channels model closely the semantics of Communicating sequential processes \n         guido von rossum said that mutable objects are enemy of multiprocesor \nthings that I am good at|\n    python|\n        sqlalchemy, \n    regular expression\n    platforms| heroku", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-me", 
            "text": "I'm a financial person and a computer person. I love to think outside of the box and to understand the bigger picture.\nI have a keen interest in how computers and how computation work in general and I enjoy understanding topics such as the  P vs NP ,  halting problem , understanding different programming paradigms, knowing how our  turing complete  machines work and more specifically the  Von Neuman architecture . Then, I strongly believe that although it is not necessary to be an expert in very low level programming, it is  imperative (pun)  that one at least know the basics of  assembler programming . Lastly, how can any programmer understand the system they are working with and understand why it works the way it does without understanding how the modern day computer and mobile phone evolved into the complex machines that we have today. One really has to do some background research into the history of computers going back to the  difference machine  and then forwarding through the world wars, understanding the need at the time for computers, how they where designed, the physical realities of the designs and implementation of those actual machines, and how concepts and jargon, which we still use today evolved. How can you understand these concepts without understanding where they came from and what they actually mean?   May takeaway is that due to economies of scale the entire Information Technology Industry has to move forward in a way that is backwards compatible. It's not that we can't use the newest physical developments to completely redesign how our computers work, its just that there won't be enough people initially to support such an en-devour and hence not enough money. Due to economies of scale we can leave CPU design to Intel, AMD and ARM and then with the help of the  impossibly  amazing technology of  photolithography , they can spend Billions on development and then mass produce CPU's at low cost. The same goes for  javascript  (for instance), a programming language that is not well designed but loved by millions because that is what they came to know. Why is Javascript so pervasive? Because all the existing websites that use it already would have to be re-written if it was replaced, and secondly and wisely, web-browser developers realized that in order to avoid  fragmentation , it would be best to just stick with the devil they know. Imagine if every browser had its own language, the web would die very quickly.  Lastly: I also enjoy knowing how the following works:  boolean algebra ,  sequential logic ,  transistors ,  logic gates ,  binary numbers .  These are just some of the things which keeps my head from cooling down  (permanently) , the other is computation theory and computation complexity theory, another detour on my road to computing guru-ship.  Currently I am enjoying the low cost of living in Philippines as I am advancing my programming skills: focusing on the following 1st:   functional programming|clojure  python| (cython, ctypes)(scrapy, django)numpy, timeit  java  web programming| javascrips, clojurescript, MEAN stack   For info on where to contact me:  RFVenter", 
            "title": "About Me"
        }, 
        {
            "location": "/about/#learning-steps", 
            "text": "", 
            "title": "Learning Steps"
        }, 
        {
            "location": "/about/#certification", 
            "text": "Treehouse  Udemy  EdX  Cousera  Freecodecamp  Codingdojo  Codeschool  Udacity  Codecademy  Eduonix", 
            "title": "Certification"
        }, 
        {
            "location": "/about/#python", 
            "text": "(cython, ctypes)(scrapy, django)numpy, timeit", 
            "title": "Python"
        }, 
        {
            "location": "/about/#java", 
            "text": "jython, android", 
            "title": "Java"
        }, 
        {
            "location": "/about/#functional-programming", 
            "text": "", 
            "title": "Functional programming"
        }, 
        {
            "location": "/about/#clojure", 
            "text": "Udemy Learning Clojure  Udemy Learning Clojure Fundamentals for Beginners  Clojure Test", 
            "title": "Clojure"
        }, 
        {
            "location": "/about/#racket", 
            "text": "the modern implementation of scheme", 
            "title": "Racket"
        }, 
        {
            "location": "/about/#haskell", 
            "text": "EdX Functional programming with Professor Meijer  C9 Lectures with Erik Meijer  Frege", 
            "title": "Haskell"
        }, 
        {
            "location": "/about/#web-programming", 
            "text": "MEAN(MongoDB, ExpressJS, AngularJS, NodeJS)", 
            "title": "Web Programming"
        }, 
        {
            "location": "/about/#other", 
            "text": "git\n    ai, datamining|\n        deep learning vs most efficient\n        statespace prunning\n        python platform\n            numpy, scikit-learn\n            data visualization\n            data mining\n        mathematics, rapidminer, r\n    gui|pyqt, kivy, wxpython, camelot\n    c|\n        go the qt route\n        c standard library (gnu c library)\n        linux system proramming in c\n        compiler|gcc, clang\n        build system|cmake\n        libraries|qt\n    debuging|\n        (gdb, pdb, winpdb) unit testing (rope) logging, assert, apport\n        pdb, bugjar, ddd\n        breakpoints, conditional breakpoints, tempory breakpoints\n        watchpoint\n            instructs the debugger to pause execution of the pro-\n            gram whenever the value of a specified variable changes.\n        logging, not print\n        asserts\n        unit tests\n    refactoring|improve design but not behaviour always with unit tests as safetynet, never refactor while \n        changing behaviour and vice versa\n    prolog\n    lua", 
            "title": "Other"
        }, 
        {
            "location": "/about/#computer-jargon", 
            "text": "", 
            "title": "Computer jargon"
        }, 
        {
            "location": "/about/#observer-pattern", 
            "text": "Is widely used in doing event-driven programming with GUI frameworks. Don't call us. Give us your telephone number, and we will call you if and when we have a job for you.", 
            "title": "Observer pattern"
        }, 
        {
            "location": "/about/#polymorphism", 
            "text": "The provision of a single interface to entities of different types. A polymorphic type is one whose operations can also be applied to values of some other type, or types.", 
            "title": "Polymorphism"
        }, 
        {
            "location": "/about/#gui-graphical-user-interface", 
            "text": "A type of user interface that allows users to interact with electronic devices through graphical icons and visual indicators such as secondary notation, instead of text-based user interfaces, typed command labels or text navigation. GUIs were introduced in reaction to the perceived steep learning curve of command-line interfaces (CLIs), which require commands to be typed on a computer keyboard.", 
            "title": "GUI (Graphical User Interface)"
        }, 
        {
            "location": "/about/#oop-object-oriented-programming", 
            "text": "A programming paradigm based on the concept of \"objects\", which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of \"this\" or \"self\"). In OOP, computer programs are designed by making them out of objects that interact with one another. There is significant diversity of OOP languages, but the most popular ones are class-based, meaning that objects are instances of classes, which typically also determine their type.\nMany of the most widely used programming languages are multi-paradigm programming languages that support object-oriented programming to a greater or lesser degree, typically in combination with imperative, procedural programming. Significant object-oriented languages include Java, C++, C#, Python, PHP, Ruby, Perl, Delphi, Objective-C, Swift, Common Lisp, and Smalltalk.", 
            "title": "OOP (Object Oriented Programming)"
        }, 
        {
            "location": "/about/#abstraction", 
            "text": "The process of picking out (abstracting) common features of objects and procedures. A programmer would \nuse abstraction, for example, to note that two functions perform almost the same task and can be combined \ninto a single function. Abstraction is one of the most important techniques in software engineering and is\nclosely related to two other important techniques - encapsulation and information hiding. All three\ntechniques are used to reduce complexity.", 
            "title": "Abstraction"
        }, 
        {
            "location": "/about/#algorithm", 
            "text": "A formula or set of steps for solving a particular problem. To be an algorithm, a set of rules must be unambiguous and have a clear stopping point. Algorithms can be expressed in any language, from natural languages like English or French to programming languages.\nWe use algorithms every day. For example, a recipe for baking a cake is an algorithm. Most programs, with the exception of some artificial intelligence applications, consist of algorithms.", 
            "title": "Algorithm"
        }, 
        {
            "location": "/about/#bug", 
            "text": "An error or defect in software or hardware that causes a program to malfunction. According to folklore, the first computer bug was an actual bug. Discovered by Lieutenant Grace Hopper in 1945 at Harvard, a moth trapped between two electrical relays of the Mark II Aiken Relay Calculator caused the whole machine to shut down.", 
            "title": "Bug"
        }, 
        {
            "location": "/about/#constant", 
            "text": "In programming, a constant is a value that never changes.", 
            "title": "Constant"
        }, 
        {
            "location": "/about/#dynamic-variable", 
            "text": "In programming, a dynamic variable is a variable whose address is determined when the program is run. In contrast, a static variable has memory reserved for it at compilation time.", 
            "title": "Dynamic Variable"
        }, 
        {
            "location": "/about/#encapsulation", 
            "text": "In programming, the process of combining elements to create a new entity. For example, a procedure is a type of encapsulation because it combines a series of computer instructions. Likewise, a complex data type, such as a record or class, relies on encapsulation. Object-oriented programming languages rely heavily on encapsulation to create high-level objects. Encapsulation is closely related to abstraction and information hiding.", 
            "title": "Encapsulation"
        }, 
        {
            "location": "/about/#exception", 
            "text": "A condition, often an error, that causes the program or microprocessor to branch to a different routine. The terms interrupt and exception are very close in meaning. Both can be used to refer to either hardware or software. The only real difference is that an exception usually indicates an error condition.", 
            "title": "Exception"
        }, 
        {
            "location": "/about/#flow-control", 
            "text": "", 
            "title": "Flow Control"
        }, 
        {
            "location": "/about/#in-communications", 
            "text": "The process of adjusting the flow of data from one device to another to ensure that the receiving device can handle all of the incoming data. This is particularly important where the sending device is capable of sending data much faster than the receiving device can receive it.", 
            "title": "In communications"
        }, 
        {
            "location": "/about/#in-programming", 
            "text": "The statements and other constructs that control the order in which operations are executed. For example, common looping statements such as for\u2026next and while are known as flow control statements. Branching statements, such as if\u2026then are also part of a programming language's flow control mechanism.", 
            "title": "In programming"
        }, 
        {
            "location": "/about/#garbage-in-garbage-out", 
            "text": "if invalid data is entered into a system, the resulting output will also be invalid. Although originally applied to computer software, the axiom holds true for all systems, including, for example, decision-making systems.", 
            "title": "Garbage In, Garbage Out"
        }, 
        {
            "location": "/about/#heuristic-programming", 
            "text": "A branch of artificial intelligence, which uses heuristics - common-sense rules drawn from experience - to solve problems. This is in contrast to algorithmic programming, which is based on mathematically provable procedures. Heuristic programming is characterized by programs that are self-learning; they get better with experience. Heuristic programs do not always reach the very best result but usually produce a good result. Many expert systems use heuristic programming.", 
            "title": "Heuristic Programming"
        }, 
        {
            "location": "/about/#information-hiding", 
            "text": "The process of hiding details of an object or function. Information hiding is a powerful programming technique because it reduces complexity. One of the chief mechanisms for hiding information is encapsulation - combining elements to create a larger entity. The programmer can then focus on the new object without worrying about the hidden details. In a sense, the entire hierarchy of programming languages - from machine languages to high-level languages - can be seen as a form of information hiding.\nalso used to prevent programmers from changing - intentionally or unintentionally - parts of a program.", 
            "title": "Information Hiding"
        }, 
        {
            "location": "/about/#iteration", 
            "text": "A single pass through a group of instructions. Most programs contain loops of instructions that are executed over and over again. The computer iterates through the loop, which means that it repeatedly executes the loop.", 
            "title": "Iteration"
        }, 
        {
            "location": "/about/#loop", 
            "text": "In programming, a loop is a series of instructions that is repeated until a certain condition is met. Each pass through the loop is called an iteration. Loops constitute one of the most basic and powerful programming concepts.", 
            "title": "Loop"
        }, 
        {
            "location": "/about/#memory-leak", 
            "text": "A bug in a program that prevents it from freeing up memory that it no longer needs. As a result, the program grabs more and more memory until it finally crashes because there is no more memory left.", 
            "title": "Memory Leak"
        }, 
        {
            "location": "/about/#mutex", 
            "text": "Short for mutual exclusion object. In computer programming, a mutex is a program object that allows multiple program threads to share the same resource, such as file access, but not simultaneously. When a program is started, a mutex is created with a unique name. After this stage, any thread that needs the resource must lock the mutex from other threads while it is using the resource. The mutex is set to unlock when the data is no longer needed or the routine is finished.", 
            "title": "Mutex"
        }, 
        {
            "location": "/about/#parse", 
            "text": "In linguistics, to divide language into small components that can be analyzed. \nParsing is often divided into lexical analysis and semantic parsing. Lexical analysis concentrates on dividing strings into components, called tokens, based on punctuation and other keys. Semantic parsing then attempts to determine the meaning of the string.", 
            "title": "Parse"
        }, 
        {
            "location": "/about/#refactoring", 
            "text": "Improving the design of existing software code. Refactoring doesn't change the observable behavior of the software; it improves its internal structure. For example, if a programmer wants to add new functionality to a program, he may decide to refactor the program first to simplify the addition of new functionality in order to prevent software entropy.", 
            "title": "Refactoring"
        }, 
        {
            "location": "/about/#regression-testing", 
            "text": "The selective retesting of a software system that has been modified to ensure that any bugs have been fixed and that no other previously-working functions have failed as a result of the reparations and that newly added features have not created problems with previous versions of the software. Also referred to as verification testing, regression testing is initiated after a programmer has attempted to fix a recognized problem or has added source code to a program that may have inadvertently introduced errors. It is a quality control measure to ensure that the newly-modified code still complies with its specified requirements and that unmodified code has not been affected by the maintenance activity.", 
            "title": "Regression Testing"
        }, 
        {
            "location": "/about/#runtime", 
            "text": "Occurring while a program is executing. For example, a runtime error is an error that occurs during program execution and a runtime library is a library of routines that are bound to the program during execution. In contrast, compile-time refers to events that occur while a program is being compiled.", 
            "title": "Runtime"
        }, 
        {
            "location": "/about/#scalable", 
            "text": "how well a hardware or software system can adapt to increased demands. For example, a scalable network system would be one that can start with just a few nodes but can easily expand to thousands of nodes. Scalability can be a very important feature because it means that you can invest in a system with confidence you won't outgrow it.", 
            "title": "Scalable"
        }, 
        {
            "location": "/about/#semaphore", 
            "text": "A hardware or software flag. In multitasking systems, a semaphore is a variable with a value that indicates the status of a common resource. Its used to lock the resource that is being used. A process needing the resource checks the semaphore to determine the resource's status and then decides how to proceed.", 
            "title": "Semaphore"
        }, 
        {
            "location": "/about/#software-entropy", 
            "text": "The tendency for software, over time, to become difficult and costly to maintain. A software system that undergoes continuous change, such as having new functionality added to its original design, will eventually become more complex and can become disorganized as it grows, losing its original design structure.", 
            "title": "Software Entropy"
        }, 
        {
            "location": "/about/#stateless", 
            "text": "Having no information about what occurred previously. Most modern applications maintain state, which means that they remember what you were doing last time you ran the application, and they remember all your configuration settings. This is extremely useful because it means you can mold the application to your working habits.", 
            "title": "Stateless"
        }, 
        {
            "location": "/about/#virtual-machine", 
            "text": "A self-contained operating environment that behaves as if it is a separate computer. For example, Java applets run in a Java virtual machine (VM) that has no access to the host operating system.", 
            "title": "Virtual Machine"
        }, 
        {
            "location": "/about/#white-box-testing", 
            "text": "Also known as glass box, structural, clear box and open box testing. A software testing technique whereby explicit knowledge of the internal workings of the item being tested are used to select the test data. Unlike black box testing, white box testing uses specific knowledge of programming code to examine outputs. The test is accurate only if the tester knows what the program is supposed to do. He or she can then see if the program diverges from its intended goal. White box testing does not account for errors caused by omission, and all visible code must also be readable.", 
            "title": "White Box Testing"
        }, 
        {
            "location": "/about/#my-thoughts", 
            "text": "python|\n        syntax,  c interop,  vm\n    programming is about using other peoples code. understanding what they mean, so understanding the language that they use to describe what is happening. there is much confusion, misunderstanding and ambiguity.\n    remove goto|reduced complexity\n    add concurrency|add complexity\n    add multiple inheritance|add complexity\n    event driven programming|\n        still procedural but set of instructions that happen on some event happening\n    easy of programming|\n        the code/test cycle, easy for new users but can go all the way to most low level\n    pointers|\n        pointing to data, pointing to function, pointing to loop, pointing to branching\n    lowest common denominator of turing|\n        jump, branch, change\n        i/o (memory, interupts)\n        memory access\n    asm|\n        registers\n        functions|\n            Function call problems\n                Calling and returning\n                Passing parameters\n                Storing local variables\n                Handling registers without interference\n                Returning values\n        heap, stack\n    c|\n        no extensive use of goto (mostly removed)\n        pointers\n    c++|\n        Another distinction is the use of the terms public and private within the class definition.\n    python|\n        The primary advantage of an interpreted language is greater platform-independence. The same source code can be distributed for use on different computing platforms, so long as each platform has a valid interpreter.", 
            "title": "My Thoughts"
        }, 
        {
            "location": "/about/#my-programming-language", 
            "text": "Abstractions are good, reality is better. Due to the realities of computation complexity, the higher level a language the slower it will be. If the programmer has no idea of the underlying of what the language is doing then the programmer looses grip on the program and the fact that it actually executes in TIME and a real MACHINE. Programs will always require real world resources.   Program in high level and selectively cut out features in order to speed up the execution all the way down.  Why are programming languages syntax so unintuitive and ugly, verbose? Make a clean, simple syntax.      test, jump, change\n    length, speed\n    start to finish, programming is a set of instructions followed from start to finish, with conditional jumps around.\n    runtime, compile time\n    native, vm\n    source protect\n    interop, c, python\n    dynamic, typed\n    functional, oop, event driven\n    if, when, event\n    goto, tabed, debug, exception, assert (commenting), introspection\n    namespace|\n        namespace is just a way to organise code\n        also object inheritance is just code organise method\n    why text,language?|\n        because the code is linear, variable names serve as a type of documentation and visual que, more information in source code means more space to add extra info for programmer to be able to understand the code\n        documentation for everything, because its called language so use language to describe what happens in computer world\n        even pics, html\n    must be tab seperated (like python) with optional static typing all the way down to c abstract syntax tree compatible without interpreter.\n    must be compatible with existing c/c++ objects and also existing python object files.\n    basically python/cython but may differ slightly to include new features, like static typing\n    remove the gil and replace vm with llvm type vm;\n    use llvmir for permision control of code\n    different levels of execution|\n        native, vm, both|\n        each level has feature on/off|\n            exceptions (exception tree, swith off lower down)\n            garbage collection, memory allocation (malloc), pointers\n            dynamic/static typing\n            encapsulation\n        dynamic recompilation\n        repl\n        introspective capabilities\n        compile-time, the less work there is to be done at run-time.\n        run time|\n            compilation\n            garbage collection\n            exceptions\n            dynamic typing\n                duck typing\n                    call by name, dictionaries\n    llvm|some are more critical of this sandboxing technology as it has substantial or substantive interoperability issues.\n        asm, llvmir, c, c++ (libraries compatible), new language\n            java (libraries not compatible)\n            python (libraries not compatible)        \n    c/c++ to my langauge converter\n    language compatibility with c, c++, java?\n    concurrency\n         These sorts of problems with shared resources require the use of concurrency control, or non-blocking algorithms.\n         Go Channels model closely the semantics of Communicating sequential processes \n         guido von rossum said that mutable objects are enemy of multiprocesor \nthings that I am good at|\n    python|\n        sqlalchemy, \n    regular expression\n    platforms| heroku", 
            "title": "My Programming Language"
        }, 
        {
            "location": "/blog/0161001/", 
            "text": "Time to share\n\n\n2016/10/01\n\n\nSo as I was doing a Google search today in relation to my programming work. I realized that it's time for a blog site. With so much information in my head as well as opinions about computation, computers, and programming in general, its time that I share that knowledge to others.\n\n\nGit mass rename\n\n\n2016/10/01\n\n\nI was doing some searching today to find out how I can rename files without using the Git utility. The reason was that I was given about 3,000 files which all needed to be mass renamed with. I am using an excellent utility on Windows called \nAdvanced Renamer\n, which allows me to do Regex search and replace on file names.\n\n\nSo the only option would have been to just do the renaming on files in the repo and then just add them again afterwards. So after doing this what I noticed was that the repo folder wasn't actually significantly larger, as these files where large all together.\n\n\nGit stores file information with an object-ID, which is unique for whatever data is in a file. If one moves a file and then adds that file again to be tracked by git (in the new folder) then git will be smart enough to detect that its the same file. However if we do a commit before adding the moved file to be tracked, then git will 1st remove the files old location and then it wont detect the change. So here is how you would do it with the git command line:\n\n\nmkdir lib\nmv hello.html lib\ngit add lib/hello.html\ngit rm hello.html\n\n\n\n\nCompiler feature turnoff\n\n\n2016/10/01\n\n\nI have often been thinking why programming is so, well, un-intuitive. Why is it so hard? People who know little about programming and new programmers ofter believe that you simply somehow tell the computer what it needs to be doing and it will figure it out by itself. Like \n\n\nProgramming is the art of using other peoples work. We use processors which have been designed by very cleaver people, mass produced so that we can afford to buy some, by the people who write code and then share it. The reason its so hard it because of the sheer amount of code, data and hence inherent complexity that goes with that. Any additional feature has the potential to add exponential complexity to any domain.\n\n\nAnyways, regarding dynamic typing: is there no way to turn this feature of for certain sections of code. Take as an example cython. Cython is code with python syntax (mostly) but compiles to static native c code. Why does the python language in conjunction with the python compiler not just enable all code to turn on/off dynamic typing for certain parts of the abstract syntax tree. In fact why can't we design a language which does the same for all modern programming language features including, garbage collection, exception handling. Why cant you prototype your programs and when your ready selective turn off features while maintaining most of your existing code in a single clean syntax? \n\n\nBy looking at the python compiler it is clear that something like this would not even be considered as the mantra in that community is to keep the compiler as easy to understand as possible even at the cost of speed. Its so obvious that the compiler sometimes adds dead byte code at the end of functions simply because no-one is bothered to add complexity to the compiler. The objective in python is not speed, and I think that is very sad. I believe that \nnative\n is and will always be very relevant, and enabling programmer to learn one language which can deal with native as well as features will be extremely helpful.", 
            "title": "Time to share"
        }, 
        {
            "location": "/blog/0161001/#time-to-share", 
            "text": "2016/10/01  So as I was doing a Google search today in relation to my programming work. I realized that it's time for a blog site. With so much information in my head as well as opinions about computation, computers, and programming in general, its time that I share that knowledge to others.", 
            "title": "Time to share"
        }, 
        {
            "location": "/blog/0161001/#git-mass-rename", 
            "text": "2016/10/01  I was doing some searching today to find out how I can rename files without using the Git utility. The reason was that I was given about 3,000 files which all needed to be mass renamed with. I am using an excellent utility on Windows called  Advanced Renamer , which allows me to do Regex search and replace on file names.  So the only option would have been to just do the renaming on files in the repo and then just add them again afterwards. So after doing this what I noticed was that the repo folder wasn't actually significantly larger, as these files where large all together.  Git stores file information with an object-ID, which is unique for whatever data is in a file. If one moves a file and then adds that file again to be tracked by git (in the new folder) then git will be smart enough to detect that its the same file. However if we do a commit before adding the moved file to be tracked, then git will 1st remove the files old location and then it wont detect the change. So here is how you would do it with the git command line:  mkdir lib\nmv hello.html lib\ngit add lib/hello.html\ngit rm hello.html", 
            "title": "Git mass rename"
        }, 
        {
            "location": "/blog/0161001/#compiler-feature-turnoff", 
            "text": "2016/10/01  I have often been thinking why programming is so, well, un-intuitive. Why is it so hard? People who know little about programming and new programmers ofter believe that you simply somehow tell the computer what it needs to be doing and it will figure it out by itself. Like   Programming is the art of using other peoples work. We use processors which have been designed by very cleaver people, mass produced so that we can afford to buy some, by the people who write code and then share it. The reason its so hard it because of the sheer amount of code, data and hence inherent complexity that goes with that. Any additional feature has the potential to add exponential complexity to any domain.  Anyways, regarding dynamic typing: is there no way to turn this feature of for certain sections of code. Take as an example cython. Cython is code with python syntax (mostly) but compiles to static native c code. Why does the python language in conjunction with the python compiler not just enable all code to turn on/off dynamic typing for certain parts of the abstract syntax tree. In fact why can't we design a language which does the same for all modern programming language features including, garbage collection, exception handling. Why cant you prototype your programs and when your ready selective turn off features while maintaining most of your existing code in a single clean syntax?   By looking at the python compiler it is clear that something like this would not even be considered as the mantra in that community is to keep the compiler as easy to understand as possible even at the cost of speed. Its so obvious that the compiler sometimes adds dead byte code at the end of functions simply because no-one is bothered to add complexity to the compiler. The objective in python is not speed, and I think that is very sad. I believe that  native  is and will always be very relevant, and enabling programmer to learn one language which can deal with native as well as features will be extremely helpful.", 
            "title": "Compiler feature turnoff"
        }
    ]
}